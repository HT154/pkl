import "pkl:math"

abstract class Resource {
  name: String
}

class A extends Resource {
  id: String
  hidden outputs: AProperties
}

class AProperties {
  foo: Int
  someMapping: Mapping<String, Int>
  someMap: Map<Int, Int>
  someListing: Listing<Int>
  someList: List<Int>
}

class B extends Resource {
  aId: String|Reference<String>
  aProperties: AProperties|Reference<AProperties>
  aValues: Listing<Int|Reference<Int>>
}

a: A = new {
  name = "a"
  id = "some-a-value"
}

local aRef: Reference<A> = Reference(a)

b: B = new {
  name = "b"
  aId = aRef.id
  aProperties = aRef.outputs
  aValues {
    aRef.outputs.foo
    aRef.outputs.someMapping["key"]
    aRef.outputs.someMap[123]
    aRef.outputs.someListing[0]
    aRef.outputs.someList[math.maxInt]
  }
}

function renderReference(ref: Reference): String =
  if (ref.getRootValue() is Resource)
    (ref.getRootValue() as Resource).name + ref.getPath().toList().map((elem) ->
        if (elem is ReferencePropertyAccess) ".\(elem.property)"
        else "[\(elem.key)]"
      ).join("")
  else throw("can only render references rooted to Resource instances")

output {
  renderer {
    converters {
      [Reference] = (it) -> renderReference(it)
    }
  }
}
